## M. van Oijen (2024). Bayesian Compendium, 2nd edition.
## Chapter 11. Model Ensembles: BMC and BMA

  library(mvtnorm)

  logPrior <- function( b, mb.=mb, Sb.=Sb ) { dmvnorm( b, mb., Sb., log=T ) }

  logLikList <- function( b, dataList, f.=f ) {
    sum( sapply( names(dataList), function(v){ sum(
      dnorm( f.( dataList[[v]][,1], b ) [[v]],
             mean=dataList[[v]][,2], sd=dataList[[v]][,3], log=T ) ) } ) )
  }

  logPostList <- function( b, mb.=mb, Sb.=Sb, dataList, f.=f ) {
    logPrior(b, mb., Sb.) + logLikList(b, dataList, f.)
  }

  MetropolisLogPost <- function( f.=f, logp=logPost, b0=mb, SProp=Sb/100, ni.=ni, ... ) {
    bChain <- matrix( NA, nrow=ni., ncol=length(b0) ) ; bChain[1,] <- b0
    for( i in 2:ni. ) {
       b1  <- bChain[i-1,] + as.numeric( rmvnorm(1,sigma=SProp) )    # Proposal generated
       if( log(runif(1)) < logp(b1,f.=f.,...) - logp(b0,f.=f.,...) ) # Proposal accepted
            bChain[i,] <- b0 <- b1
       else bChain[i,] <- b0                                         # Proposal rejected
    }
    return(bChain)
  }

  ni <- 3e4
  
  set.seed(1)

  EXPOL5 <- function( t=0, b=c(10,1,0.007,2,1) ) {
    I0  <- b[1] # MJ PAR m-2 ground d-1
    K   <- b[2] # m2 ground m-2 leaf area
    LAR <- b[3] # m2 leaf area g-1 DM
    LUE <- b[4] # g DM MJ-1 PAR
    W0  <- b[5] # g DM m-2 ground
    W   <- log( 1 + exp(I0*K*LAR*LUE*t) * (exp(K*LAR*W0)-1) ) / (K*LAR)
    LAI <- W * LAR
    return( list( "W"=W, "LAI"=LAI ) ) }

  bmin5  <- c(  9.9, 0.5, 0.005, 1, 0.5 )
  bmax5  <- c( 10.1, 1.5, 0.009, 3, 1.5 )
  mb5    <- rowMeans( cbind(bmin5,bmax5) )
  range5 <- bmax5 - bmin5 ; var5 <- (range5^2) / 12 ; Sb5 <- diag( var5 )

  EXPOL6 <- function( t=0, b=c(10,1,3,0.007,2,1) ) {
    I0  <- b[1] ; K   <- b[2] ; LAIMAX <- b[3]
    LAR <- b[4] ; LUE <- b[5] ; W0     <- b[6]
    e1  <- exp(I0*K*LAR*LUE*t) ; e2 = exp(K*LAR*W0) ; e3 = exp(-K*LAIMAX)
    W   <- W0*e3 + ( log(e2+1/e1-1)/(K*LAR) + I0*LUE*t ) * (1-e3)
    LAI <- log( (1+e1*(e2-1)) / (1+e1*(e2-1)*e3) ) / K
    return( list( "W"=W, "LAI"=LAI ) ) }

  bmin6  <- c(  9.9, 0.5, 1, 0.005, 1, 0.5 )
  bmax6  <- c( 10.1, 1.5, 5, 0.009, 3, 1.5 )
  mb6    <- rowMeans( cbind(bmin6,bmax6) )
  range6 <- bmax6 - bmin6 ; var6 <- (range6^2) / 12 ; Sb6 <- diag(var6)

  t_W      <- c(20,60,100) ; y_W <- c(10,500,1200) ; sd_W <- c(5,15,120)
  t_L      <- c(20,80,100) ; y_L <- c(0.2,5,4)     ; sd_L <- c(0.1,1,1)
  data_W   <- cbind( t=t_W, y=y_W, sd=sd_W )
  data_LAI <- cbind( t=t_L, y=y_L, sd=sd_L )
  data     <- list( "W"=data_W, "LAI"=data_LAI )

  set.seed(1)

  mb     <- mb5 ; Sb <- Sb5
  bChain <- MetropolisLogPost( f=EXPOL5, logp=logPostList, dataList=data, mb=mb5, Sb=Sb5 )
  mb5_y  <- colMeans(bChain) ; Sb5_y  <- cov(bChain)

  mb     <- mb6 ; Sb <- Sb6

  bChain <- MetropolisLogPost( f=EXPOL6, logp=logPostList, dataList=data )

  mb6_y  <- colMeans(bChain) ; Sb6_y  <- cov(bChain)

# Bayesian calibration of the 6-parameter expolinear model ($\\texttt{EXPOL6}$)
# by means of Metropolis sampling.
  par( mfrow = c(6,2), mar=c(2,2.5,1.5,1) )
  plot(bChain[,1],pch=".") ; hist(bChain[,1],yaxt="n",main="I0"    )
  plot(bChain[,2],pch=".") ; hist(bChain[,2],yaxt="n",main="K"     )
  plot(bChain[,3],pch=".") ; hist(bChain[,3],yaxt="n",main="LAIMAX")
  plot(bChain[,4],pch=".") ; hist(bChain[,3],yaxt="n",main="LAR"   )
  plot(bChain[,5],pch=".") ; hist(bChain[,4],yaxt="n",main="LUE"   )
  plot(bChain[,6],pch=".") ; hist(bChain[,5],yaxt="n",main="W0"    )

# Growth curves generated by model $\\texttt{EXPOL6}$ for biomass (W) and
# leaf-area index (LAI). The model was run with the posterior mean parameter
# vector (thick line) and with 20 parameter vectors subsampled from the MCMC
# (thin dashed lines).
  par( mfrow = c(1,2), mar=c(4,2,2,2) )
  varName1 <- expression( 'W (kg m'^-2*')' )
  varName2 <- expression( 'LAI (m'^2*' m'^-2*')' )
  varNames <- c( varName1, varName2 )
  p        <- floor( seq(5e3, 1e4, length.out=20) )
  for(v in 1:2) {
    t.y    <- data[[v]][,"t" ]
    y      <- data[[v]][,"y"]
    t.plot <- seq( min(t.y), max(t.y), length.out=20 )
    plot  ( t.plot, sapply( t.plot, function(i){EXPOL6(i,mb6_y)[[v]]} ),
            ylim=c(0,1.1*max(y)), xlab="Time (days)", ylab="",main=varNames[v],
            lwd=3, type="l" )
    points( data[[v]], col='blue',lwd=3, cex=2 )
    for(j in 1:20) { points( t.plot, sapply( t.plot,
      function(i){EXPOL6(i,bChain[p[j],])[[v]]} ), lwd=0.5, type="l", lty=2 ) }
  }

  t_W <- c(10,20,40,80) ; y_W <- c(5,15,150,900) ; sd_W <- c(2,4,20,100)
  t_L <- c(20,80)       ; y_L <- c(0.2,4.0)      ; sd_L <- c(0.1,0.1)
  data_W   <- cbind( t=t_W, y=y_W, sd=sd_W )
  data_LAI <- cbind( t=t_L, y=y_L, sd=sd_L )
  data_NEW <- list( "W"=data_W, "LAI"=data_LAI )

  set.seed(1)

  ns            <- 1e3
  sample_b5     <- rmvnorm( n=ns, mean=mb5_y, sigma=Sb5_y )
  sample_log_L5 <- sapply( 1:ns, function(i) {
    logLikList( sample_b5[i,], dataList=data_NEW, f.=EXPOL5 ) } )
  log_IL5       <- mean(sample_log_L5) +
                   log( mean( exp(sample_log_L5-mean(sample_log_L5)) ) )
# Alternative calculation that is numerically less robust:
# sample_L5 <- exp(sample_log_L5) ; IL5 <- mean(sample_L5) ; log_IL5 <- log(IL5)

  set.seed(1)

  ns            <- 1e3
  sample_b6     <- rmvnorm( n=ns, mean=mb6_y, sigma=Sb6_y )
  sample_log_L6 <- sapply( 1:ns, function(i) {
    logLikList( sample_b6[i,], dataList=data_NEW, f.=EXPOL6 ) } )
  log_IL6       <- mean(sample_log_L6) +
                 log( mean( exp(sample_log_L6-mean(sample_log_L6)) ) )

  pM5 <- 1 / ( 1 + exp(log_IL6-log_IL5) )
  pM6 <- 1 - pM5
  print( c(pM5,pM6) )

# Exercise 1. Model precision vs. accuracy..
  IL1 <- mean( dnorm( rnorm( 1e4, 10- 8, 1 ), 0, 3 ) )
  IL2 <- mean( dnorm( rnorm( 1e4, 10-10, 4 ), 0, 3 ) )
  pM1 <- IL1 / (IL1+IL2) ; pM2 <- 1 - pM1
  